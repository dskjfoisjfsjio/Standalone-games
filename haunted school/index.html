<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Haunted School - Fix</title>
    <style>
      body { margin: 0; background: #000; overflow: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; color: white; font-family: sans-serif; }
      #unity-canvas { position: fixed; width: 100%; height: 100%; top: 0; left: 0; background: #000; }
      #loading-text { z-index: 10; font-size: 24px; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; border: 1px solid #444; }
    </style>
  </head>
  <body>
    <canvas id="unity-canvas"></canvas>
    <div id="loading-text">REBOOTING ENGINE...</div>

    <script>
    const FILES_TO_MERGE = {
        "ab206082a6481ca7afc3e8fb78d8e569.wasm": "application/wasm",
        "d21c95e37d0c4b5b0a6c9189aeafdb4c.data": "application/octet-stream"
    };

    async function fetchAndMerge(fileName, mimeType) {
        const loadingText = document.getElementById("loading-text");
        const parts = [];
        for (let i = 1; i <= 99; i++) {
            const url = `Build/${fileName}.part${i}`;
            try {
                const response = await fetch(url, { method: "HEAD" });
                if (!response.ok) break;
                parts.push(url);
            } catch (e) { break; }
        }

        if (parts.length === 0) {
            const r = await fetch("Build/" + fileName);
            return URL.createObjectURL(await r.blob());
        }

        let totalLength = 0;
        const chunks = [];
        for (let i = 0; i < parts.length; i++) {
            loadingText.innerText = `STITCHING ${fileName.split('.').pop().toUpperCase()}: ${Math.floor(((i+1)/parts.length)*100)}%`;
            const res = await fetch(parts[i]);
            const buf = await res.arrayBuffer();
            totalLength += buf.byteLength;
            chunks.push(new Uint8Array(buf));
        }

        const merged = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
            merged.set(chunk, offset);
            offset += chunk.length;
        }
        return URL.createObjectURL(new Blob([merged], { type: mimeType }));
    }

    (async () => {
        const loadingText = document.getElementById("loading-text");
        try {
            const blobMap = {};
            for (const [file, mime] of Object.entries(FILES_TO_MERGE)) {
                blobMap[file] = await fetchAndMerge(file, mime);
            }

            const origFetch = window.fetch;
            window.fetch = async (resource, options) => {
                const url = typeof resource === 'string' ? resource : resource.url;
                const key = url.split('/').pop();
                if (blobMap[key]) return origFetch(blobMap[key], options);
                if (url.includes("StreamingAssets/")) {
                    return origFetch("./StreamingAssets/" + url.split("StreamingAssets/")[1], options);
                }
                return origFetch(resource, options);
            };

            const config = {
                dataUrl: "Build/d21c95e37d0c4b5b0a6c9189aeafdb4c.data",
                frameworkUrl: "Build/9d1367265b5f606c3643cb09fc403c5f.js",
                codeUrl: "Build/ab206082a6481ca7afc3e8fb78d8e569.wasm",
                streamingAssetsUrl: "StreamingAssets",
                companyName: "Haunted School",
                productName: "Haunted School",
                productVersion: "1.0.0",
                // FIX: Turned the string into a function that returns the string
                cacheControl: function(url) {
                    return "no-store";
                },
            };

            const script = document.createElement("script");
            script.src = "Build/be5c8a837410560f3ca8989808c21df4.js";
            script.onload = () => {
                createUnityInstance(document.querySelector("#unity-canvas"), config, (p) => {
                    loadingText.innerText = "LOADING: " + Math.floor(p * 100) + "%";
                }).then(() => {
                    loadingText.style.display = "none";
                }).catch((err) => {
                    loadingText.innerText = "ENGINE CRASH: " + err.message;
                });
            };
            document.body.appendChild(script);
        } catch (e) {
            loadingText.innerText = "BOOT ERROR: " + e.message;
        }
    })();
    </script>
  </body>
</html>